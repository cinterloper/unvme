<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <meta name="description" content="User Space NVMe Driver">
    <meta name="robots" content="index,follow">
    <meta name="keywords" content="unvme, nvme, userspace NVMe driver, user space NVMe driver, ssd, userspace driver, user space driver, micron, spdk, github">
    <title>UNVMe by Micron</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <img src="logomicron.png" alt="Micron Logo"/>
      <h1 class="project-name">UNVMe</h1>
      <h2 class="project-tagline">User Space NVMe Driver by Micron Technology</h2>
      <a href="https://github.com/MicronSSD/unvme" class="btn">View on GitHub</a>
      <a href="https://github.com/MicronSSD/unvme/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/MicronSSD/unvme/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="unvme---a-user-space-nvme-driver-project" class="anchor" href="#unvme---a-user-space-nvme-driver-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>UNVMe - A User Space NVMe Driver Project</h1>

<p>UNVMe is a user space NVMe driver developed at Micron Technology for the
purpose of benchmarking different polling models in comparison to the
kernel space NVMe driver interupt driven model.</p>

<p>The UNVMe driver depends on features provided by the vfio module in the
Linux kernel (introduced since 3.6).</p>

<p>From the application perspective, UNVMe provides a single library (libunvme.a)
with a set of custom APIs for accessing NVMe devices.</p>

<p>In this project, UNVMe is implemented as three distinct models (choose one):</p>

<pre><code>model_apc   -   Using this library model, an application will have
                exclusive access to a given NVMe device, where the
                application will process the completion queue at the time
                of checking for an I/O status.  In this model, there will
                be no context switch in the submission and completion paths.


model_tpc   -   Using this library model, an application will have
                exclusive access to a given NVMe device, where a built-in
                thread will automatically process I/O completion, and
                the application can retrieve results when checking for
                an I/O status.  In this model, there may be context
                switch in the completion process.

model_cs    -   Using the client/server model, the driver will run
                as a background service to manage a set of NVMe devices
                and receive requests from client applications.
                A client application which runs in a separate process can
                send requests to the driver.  This model is similar to
                the traditional driver model which allows one or more
                applications to access a device.  In this model, there may
                be context switch in both submission and completion paths.
</code></pre>

<p>A selected model can be built by specifying the named target.
All three models export the same set of library APIs.</p>

<p>It should be noted that the UNVMe interface is designed to allow the user
to create a specified number of I/O submission-completion queue pairs.
The queues will be created exclusively for and when a session is opened.
For multi-threaded applications, an application thread can perform I/O on
one or more queues, but a queue must only be accessed by a single thread
in order to guarantee thread-safe operations.</p>

<h1>
<a id="system-requirements" class="anchor" href="#system-requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>System Requirements</h1>

<p>UNVMe has only been built and tested on CentOS 6 and 7 running on x86_64 CPU
based systems with vfio support which requires the following features:</p>

<pre><code>VT-d        -   Hardware must have Intel CPU that supports VT-d
                (Virtualization Technology for Directed I/O).

vfio        -   Linux kernel 3.6 or later, and the kernel must be built
                with these configurations enabled:

                    CONFIG_IOMMU_API=y
                    CONFIG_IOMMU_SUPPORT=y
                    CONFIG_INTEL_IOMMU=y
                    CONFIG_VFIO=m
                    CONFIG_VFIO_PCI=m
                    CONFIG_VFIO_IOMMU_TYPE1=m
                    CONFIG_INTEL_IOMMU_DEFAULT_ON=y

                If CONFIG_INTEL_IOMMU_DEFAULT_ON is not set then the boot
                command line must have "intel_iommu=on" argument set instead.

                To verify the system is correctly configured with vfio support,
                check that /sys/kernel/iommu_groups directory is not empty
                but contains other subdirectories (i.e. group numbers).
</code></pre>

<h1>
<a id="build-and-run" class="anchor" href="#build-and-run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Build and Run</h1>

<p>The Makefile.def file is provided for the user to specify the default
model to build when running:</p>

<pre><code>$ make
</code></pre>

<p>A specific model can also be built by explicitly specifying one of the
following targets:</p>

<pre><code>$ make model_apc
$ make model_tpc
$ make model_cs
</code></pre>

<p>Make will keep track of the last built model (until clean) and will default
to remake that model before using the DEFAULT_MODEL setting in Makefile.def.</p>

<p>When building model_apc or model_tpc, make will produce a 'libunvme.a' library.
When building the model_cs, make will produce a 'libunvme.a' library and
a 'unvme' executable which is the driver to be run as a service.</p>

<p>If the model_cs is built, then the service needs to be run specifying a list
of mapped vfio devices as its arguments, i.e. prior to running applications.
For example:</p>

<pre><code>$ src/unvme /dev/vfio/X /dev/vfio/Y ...
</code></pre>

<p>The UNVMe runtime log messages will be saved in /dev/shm/unvme.log.</p>

<p>Before running the UNVMe service or applications, the user must first run
the setup script once to bind all the NVMe to vfio devices using the following
command:</p>

<pre><code>$ test/unvme-setup
</code></pre>

<p>To reset the devices to the default NVMe kernel space drivers, run command:</p>

<pre><code>$ test/unvme-setup reset
</code></pre>

<h1>
<a id="applications-and-tests" class="anchor" href="#applications-and-tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Applications and Tests</h1>

<p>Applications can be built using the libunvme.h and libunvme.a interfaces.
The library provides the APIs for UNVMe as well as direct NVMe commands
with vfio functions support for DMA allocation.</p>

<p>Examples of both UNVMe and NVMe level testing are provided under the test
directory.</p>

<p>UNVMe test applications can be run as:</p>

<pre><code>$ test/unvme/unvme_api_test /dev/vfio/X
$ test/unvme/unvme_mts_test /dev/vfio/X
...
</code></pre>

<p>NVMe direct access tests (bypassing UNVMe driver) can be run as:</p>

<pre><code>$ test/nvme/nvme_identify /dev/vfio/X          # identify controller
$ test/nvme/nvme_identify /dev/vfio/X 1        # identify namespace 1
$ test/nvme/nvme_get_log_page /dev/vfio/X 1 1  # get log page error info
$ test/nvme/nvme_get_log_page /dev/vfio/X 1 2  # get log page SMART health
$ test/nvme/nvme_get_log_page /dev/vfio/X 1 3  # get log page firmware slot
...
</code></pre>

<h1>
<a id="benchmark" class="anchor" href="#benchmark" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Benchmark</h1>

<p>UNVMe has been benchmarked with fio (Flexible I/O Tester) using the test
script test/unvme-benchmark.  The ioengine/unvme_fio is provided for
this purpose.  In order to build the unvme_fio engine, the user must either
set the FIO_DIR variable to point to the fio source path in the Makefile.def
or specify FIO_DIR on the make command line as:</p>

<pre><code>$ FIO_DIR=/path/fio make model_apc
</code></pre>

<p>To produce benchmark results for UNVMe model_apc, run:</p>

<pre><code>$ test/unvme-setup  # only need to be done once if has not
$ make model_apc
$ OUTDIR=out/apc test/unvme-benchmark /dev/vfio/X
</code></pre>

<p>To produce benchmark results for UNVMe model_tpc, run:</p>

<pre><code>$ make model_tpc
$ OUTDIR=out/tpc test/unvme-benchmark /dev/vfio/X
</code></pre>

<p>To produce benchmark results for UNVMe model_cs, run:</p>

<pre><code>$ make model_cs
$ src/unvme /dev/vfio/X ...
$ OUTDIR=out/cs test/unvme-benchmark /dev/vfio/X
</code></pre>

<p>To reset and get benchmark results for the NVMe kernel space driver, run:</p>

<pre><code>$ test/unvme-setup reset
$ OUTDIR=out/nvme test/unvme-benchmark /dev/nvme0n1
</code></pre>

<p>Notes on unvme-benchmark script:</p>

<pre><code>+ The unvme-benchmark script will run fio tests for random read and then
  random write using 1, 4, 8, and 16 jobs (threads) with iodepth of
  1, 4, 8, 16, 32, and 64.

+ For UNVMe, the number of fio jobs will be translated to the number of
  queues and iodepth (+1) will be the queue size.

+ The default output directory will be "out" relative to the test directory
  where the unvme-benchmark script resides.  The outut directory can also
  be overriden by specifying OUTDIR on the shell command line.

+ If the tested device nsid is other than 1 then the variable NSID must be
  specified on the shell command line.

+ The FIO_DIR should be set in Makefile.def where the fio source code
  and executable are found.
</code></pre>

<h1>
<a id="documentation" class="anchor" href="#documentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Documentation</h1>

<p>Doxygen formatted documents for the source code can be generated as:</p>

<pre><code>$ make doc
</code></pre>

<p>The output HTML based document can then be browsed from doc/html/index.html.</p>

<h1>
<a id="questions-and-comments" class="anchor" href="#questions-and-comments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions and Comments:</h1>

<p>Please feel free to create new issue for questions and comments.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/MicronSSD/unvme">Unvme</a> is maintained by <a href="https://github.com/MicronSSD">MicronSSD</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
